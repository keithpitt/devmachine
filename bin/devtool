#!/usr/bin/env bash

source "$DEVMACHINE_PATH/lib/devmachine.sh"

main() {
  local tool_path="$1"
  local cmd="$2"

  if [[ "$cmd" == "" ]]; then

    tool_name="$(basename -s ".sh" "$tool_path")"

    # This peeks into the tool file and look for all the
    # case definitions, i.e. "setup)" "--check-installed" etc.
    #
    # It then strips the leading whitespace, as well as the trailing ")"
    discovered_commands=$(
      cat "$tool_path" |
        grep --extended-regexp --ignore-case '^\s*[a-z\-]+)' |
        sed -E "s/^ *//g" |
        sed -E "s/)$//g"
    )

    # Turn the discovered commands into an array
    local -a commands=()
    for cmd in $discovered_commands; do
      if [[ "$cmd" == "logo" ]]; then
        continue
      fi

      commands+=("$cmd")
    done

    source "$tool_path" "logo"

    local -i idx=1
    for cmd in ${commands[@]}; do
      printf "%s) \e[2mdevtool %s\e[0m %s\n" "$idx" "$tool_name" "$cmd"
      idx+=1
    done

    echo
    read -p "Enter 1-$idx (or blank to edit $tool_name.sh): " -r input
    echo

    if [[ "$input" == "" ]]; then
      "$EDITOR" "${DEVMACHINE_PATH}/tools/$tool_name.sh"
    else
      source "$tool_path" "${commands[$(($input - 1))]}"
    fi

  else
    source "$tool_path" "$2"
  fi
}

tool="$1"

if [[ "$tool" == "" ]]; then
  echo "no tool passed"
  exit 1
elif [[ "${tool:1:1}" == "." ]]; then
  tool=$(realpath "$tool")
else
  guess_path="$DEVMACHINE_PATH/tools/$tool.sh"
  if [[ -e "$guess_path" ]]; then
    tool="$guess_path"
  else
    echo "cant find $tool"
    exit 1
  fi
fi

main "$tool" "$2"
